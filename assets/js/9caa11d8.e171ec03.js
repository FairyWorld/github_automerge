"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8353],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),h=o,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||r;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},5732:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],s={sidebar_position:7},l="Multi-user apps",c={unversionedId:"tutorial/sync-changes",id:"tutorial/sync-changes",isDocsHomePage:!1,title:"Multi-user apps",description:"Until now, you've built an Automerge application for a single user only. But Automerge excels when there are multiple users editing a document over time, who may or may not be online at the same time.",source:"@site/docs/tutorial/sync-changes.md",sourceDirName:"tutorial",slug:"/tutorial/sync-changes",permalink:"/docs/tutorial/sync-changes",editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/tutorial/sync-changes.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Save and load",permalink:"/docs/tutorial/save-and-load"},next:{title:"Remote storage",permalink:"/docs/tutorial/remote-storage"}},u=[{value:"BroadcastChannel",id:"broadcastchannel",children:[],level:2},{value:"Sending a message",id:"sending-a-message",children:[],level:2},{value:"Receiving a message",id:"receiving-a-message",children:[],level:2},{value:"Hints",id:"hints",children:[],level:2}],d={toc:u};function p(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"multi-user-apps"},"Multi-user apps"),(0,r.kt)("p",null,"Until now, you've built an Automerge application for a single user only. But Automerge excels when there are multiple users editing a document over time, who may or may not be online at the same time."),(0,r.kt)("h2",{id:"broadcastchannel"},"BroadcastChannel"),(0,r.kt)("p",null,"In this tutorial, we will use a ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel"},"BroadcastChannel"),", which allows you to simulate a local area network. All tabs and windows on the same domain in the browser will be able to send and receive messages from each other. In a production application, you could use a WebSocket, WebRTC server, HTTP server, or simply send binary files around. "),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"NOTE: BroadcastChannel is not available in IE or Safari. You must install the Safari Technical Preview or use another browser, such as Chrome, Brave, or Firefox.")),(0,r.kt)("p",null,"Each channel has its own ID. We use the ",(0,r.kt)("inlineCode",{parentName:"p"},"docId"),", which allows us to send messages to any other browser tab or iframe that has the ID."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let docId = window.location.hash.replace(/^#/, '')\nlet channel = new BroadcastChannel(docId)\n")),(0,r.kt)("h2",{id:"sending-a-message"},"Sending a message"),(0,r.kt)("p",null,"Every time the todo list is updated in one tab, we want to inform all the other tabs that they also need to update their copies of the document. To do this, we once again hook into the ",(0,r.kt)("inlineCode",{parentName:"p"},"updateDoc()")," function. Besides rendering and saving a document, it now also sends a message containing the updated document to the other tabs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"function updateDoc(newDoc) {\n  doc = newDoc\n  render(newDoc)\n  let binary = Automerge.save(newDoc)\n  localforage.setItem(docId, binary).catch(err => console.log(err))\n  channel.postMessage(binary) // <-- this line is new\n}\n")),(0,r.kt)("p",null,"Note that we pass the binary data generated by ",(0,r.kt)("inlineCode",{parentName:"p"},"Automerge.save()")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"channel.postMessage()"),". You can't send the Automerge document object ",(0,r.kt)("inlineCode",{parentName:"p"},"doc")," directly because the browser doesn't know how to serialize it."),(0,r.kt)("h2",{id:"receiving-a-message"},"Receiving a message"),(0,r.kt)("p",null,"We can now register a ",(0,r.kt)("inlineCode",{parentName:"p"},"channel.onmessage")," callback that will get called on every other browser tab on which you have opened the same URL. In the callback we first use ",(0,r.kt)("inlineCode",{parentName:"p"},"Automerge.load()")," to unserialize the binary data in the message, and then call ",(0,r.kt)("inlineCode",{parentName:"p"},"Automerge.merge()")," to merge it with the document in the current tab:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"channel.onmessage = (ev) => {\n  let newDoc = Automerge.merge(doc, Automerge.load(ev.data))\n  doc = newDoc\n  render(newDoc)\n}\n")),(0,r.kt)("p",null,"After merging, we update the global variable ",(0,r.kt)("inlineCode",{parentName:"p"},"doc")," and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"render()")," function to update the todo list in the page. We don't call ",(0,r.kt)("inlineCode",{parentName:"p"},"updateDoc()")," here because that would call ",(0,r.kt)("inlineCode",{parentName:"p"},"postMessage")," again, resulting in an infinite loop where two tabs continually bounce messages back and forth."),(0,r.kt)("p",null,"Now, test it! Copy and paste your URL into a new window in the same browser, so that you have two windows or tabs with the same docId. In one browser tab, add a new item. It should immediately appear on the other tab as well."),(0,r.kt)("h2",{id:"hints"},"Hints"),(0,r.kt)("p",null,"This approach of sending each other serialized documents, and merging them, works just as well over a network as between tabs in the same browser. However, if your documents get big, then it is inefficient to repeatedly send each other the entire serialized document."),(0,r.kt)("p",null,"As an alternative, it's possible to encode only the changes that have been made since the last sync, and send those. You can find more information on how to do this in the ",(0,r.kt)("a",{parentName:"p",href:"/docs/cookbook/real-time"},"Cookbook"),"."))}p.isMDXComponent=!0}}]);